<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>One-Sided Device-Tilt Scaling</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.6.0/p5.js"></script>
  <style>
    body { margin: 0; overflow: hidden; background: #000; color: #fff; }
    #motionBtn {
      position: absolute;
      top: 20px;
      left: 20px;
      z-index: 10;
      padding: 10px 20px;
      font-size: 16px;
    }
  </style>
</head>
<body>
  <button id="motionBtn">Enable Motion Effects</button>
  <script>
    // ——— Your Letters ———
    let letters = ["i", "c", "z", "b", "g", "v"];
    
    // we’ll measure the widest letter so we know our “word half-width”:
    let halfWordWidth = 0;

    // ——— Motion / Permission Logic ———
    let permissionGranted   = false;
    const deadZone          = 1;
    const smoothingFactor   = 0.15;
    const updateInterval    = 50;
    const maxTilt           = 45;
    let lastScaleFactorX    = 13;   // start fully “zoomed out” at 13×
    let lastUpdateTime      = 0;
    let lastTiltLR          = 0;

    function requestMotionPermission() {
      if (typeof DeviceOrientationEvent.requestPermission === 'function') {
        DeviceOrientationEvent.requestPermission()
          .then(res => res === 'granted' ? enableMotion() : console.warn('Denied'))
          .catch(err => console.error(err));
      } else {
        enableMotion();
      }
    }

    function enableMotion() {
      permissionGranted = true;
      select('#motionBtn').hide();
      window.addEventListener('deviceorientation', handleOrientation);
    }

    function handleOrientation(event) {
      if (!permissionGranted) return;
      const tiltLR = event.gamma;  // left(−) ↔ right(+)

      if (Math.abs(tiltLR) < deadZone) return;
      const now = Date.now();
      if (now - lastUpdateTime < updateInterval) return;
      lastUpdateTime = now;

      lastTiltLR = tiltLR;

      // normalize and map 0→13 down to 0.2
      const t = Math.min(Math.abs(tiltLR), maxTilt) / maxTilt;
      let rawScaleX = 13 - t * (13 - 0.2);
      rawScaleX = constrain(rawScaleX, 0.2, 13);

      lastScaleFactorX += smoothingFactor * (rawScaleX - lastScaleFactorX);
    }
    // ————————————————————————————

    function setup() {
      createCanvas(windowWidth, windowHeight);
      textSize(128);
      textAlign(CENTER, CENTER);
      noStroke();
      fill(255);
      textLeading(textSize() * 0.8);

      // measure the widest letter
      for (let l of letters) {
        halfWordWidth = max(halfWordWidth, textWidth(l));
      }
      halfWordWidth /= 2;

      select('#motionBtn').mousePressed(requestMotionPermission);
    }

    function draw() {
      background(0);

      // choose anchor side based on last tilt direction
      // if tilting right → anchor at left edge  (x = −halfWordWidth)
      // if tilting left  → anchor at right edge (x = +halfWordWidth)
      const anchorX = lastTiltLR > 0 ? -halfWordWidth : halfWordWidth;

      push();
        translate(width/2, height/2);

        // move origin to the anchor edge:
        translate(anchorX, 0);

        // apply the one-sided scale:
        scale(lastScaleFactorX, 1);

        // move back so letters draw centered around word center:
        translate(-anchorX, 0);

        // draw column of letters at x=0
        for (let i = 0; i < letters.length; i++) {
          let y = (i - (letters.length - 1) / 2) * textLeading();
          text(letters[i], 0, y);
        }
      pop();
    }

    function windowResized() {
      resizeCanvas(windowWidth, windowHeight);
    }
  </script>
</body>
</html>
